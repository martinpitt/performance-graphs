#!/usr/bin/python3
# Run this with --help to see available options for tracing and debugging
# See https://github.com/cockpit-project/cockpit/blob/master/test/common/testlib.py
# "class Browser" and "class MachineCase" for the available API.

import os
import re
import sys
import time
import datetime

# import Cockpit's machinery for test VMs and its browser test API
TEST_DIR = os.path.dirname(__file__)
sys.path.append(os.path.join(TEST_DIR, "common"))
sys.path.append(os.path.join(os.path.dirname(TEST_DIR), "bots/machine"))
import testlib


class TestApplication(testlib.MachineCase):

    def getMaximumSpike(self, g_type, saturation, hour, minute):
        b = self.browser
        sel = "#metrics-hour-{0} div.metrics-data-{1}[style='--metrics-minute:{2};'] polygon".format(hour, g_type, minute)
        if saturation:
            sel += ":nth-child(2)"
        else:
            sel += ":first-child"

        points = b.attr(sel, "points").split(" ")
        xs = [float(x.split(",")[0]) for x in points]

        return max(xs)

    def prepareArchive(self, name, time):
        self.machine.upload(["archives/{0}".format(name)], "/tmp/")
        self.machine.execute("""timedatectl set-ntp off
                                systemctl stop pmlogger
                                rm -rf /var/log/pcp/pmlogger/*
                                tar -C / -xzvf /tmp/{0}
                                timedatectl set-time @{1}""".format(name, time))

    def testBasic(self):
        b = self.browser
        m = self.machine

        m.execute("systemctl start pmlogger")

        self.login_and_go("/performance-graphs")
        # eventually finishes data loading and shows heading
        b.wait_in_text(".metrics-history", "Events")
        b.wait_in_text(".metrics-history", "CPU")
        b.wait_present(".metrics-hour .metrics-data-cpu")

        # only shows current hour
        b.wait_js_func("ph_count_check", ".metrics-hour", 1)

        # VM just started, we don't have 12 hours of data
        b.wait_in_text(".metrics .pf-c-alert", "No data available between")
        # initial data gap is < 24 hours, does not show date
        year = m.execute("date +%Y").strip()
        self.assertNotIn(year, b.text(".metrics .pf-c-alert"))

        # can try to load earlier data; only updates "no data" alert as there is no data
        b.wait_text(".bottom-panel button", "Load earlier data")
        b.click(".bottom-panel button")
        # now the gap is > 24 hours, does show date
        b.wait_in_text(".metrics .pf-c-alert", year)
        # still only one hour
        b.wait_js_func("ph_count_check", ".metrics-hour", 1)

        # should only have at most three valid minutes, the rest should be empty
        valid_start = b.call_js_func("ph_count", ".metrics-data-cpu.valid-data")
        self.assertLessEqual(valid_start, 3)
        # leave one minute wiggle room, in case the page updates between these two checks
        self.assertGreaterEqual(b.call_js_func("ph_count", ".metrics-data-cpu.empty-data"), 59 - valid_start)
        # page auto-updates every minute
        with b.wait_timeout(90):
            b.wait_js_func("(exp => ph_count('.metrics-data-cpu.valid-data') == exp)", valid_start + 1)

        # there are often some initial events at machine startup
        initial_events = b.call_js_func("ph_count", ".metrics-events")

        # memory saturation event
        now = datetime.datetime.now()
        minute_start = now.minute
        hour_start = int(datetime.datetime.timestamp(now.replace(minute=0, second=0))) * 1000

        mem_hog = m.spawn("MEMBLOB=$(yes | dd bs=1M count=500 iflag=fullblock); sleep infinity", "mem_hog.log")
        time.sleep(30)
        m.execute("kill %d" % mem_hog)

        now = datetime.datetime.now()
        minute_end = now.minute
        hour_end = int(datetime.datetime.timestamp(now.replace(minute=0, second=0))) * 1000

        # UI auto-updates every minute, so it should pick up the new spike within the next 30s
        b.wait_js_func("(exp => ph_count('.metrics-events') == exp)", initial_events + 1)

        # We cannot just wait for spike, as we are not sure, in which minute it actually is (it
        # might be in the starting minute or in the ending one).
        # Thus just get maximum spike from both, pick the bigger and assert it is what we expect
        start_spike = self.getMaximumSpike("memory", True, hour_start, minute_start)
        end_spike = self.getMaximumSpike("memory", True, hour_end, minute_end)
        spike = max(start_spike, end_spike)
        self.assertGreaterEqual(spike, 0.9)

        # in our CI this ends up as a net swap event, and no actual used memory increase
        b.wait_in_text(".metrics-events:last-of-type", "Swap")

    def testDisks(self):
        b = self.browser
        m = self.machine

        self.prepareArchive("disk.tar.gz", 1597672800)

        self.login_and_go("/performance-graphs")
        # eventually finishes data loading and shows heading
        b.wait_in_text(".metrics-history", "Events")
        b.wait_in_text(".metrics-history", "CPU")
        b.wait_present(".metrics-hour .metrics-data-cpu")

        # Big spike lasting 3 minutes
        self.assertGreaterEqual(self.getMaximumSpike("disks", False, 1597662000000, 25), 0.9)
        self.assertGreaterEqual(self.getMaximumSpike("disks", False, 1597662000000, 26), 0.9)
        self.assertGreaterEqual(self.getMaximumSpike("disks", False, 1597662000000, 27), 0.9)

        # Smaller spike lasting 2 minutes
        self.assertGreaterEqual(self.getMaximumSpike("disks", False, 1597662000000, 28), 0.4)
        self.assertLessEqual(self.getMaximumSpike("disks", False, 1597662000000, 28), 0.6)
        self.assertGreaterEqual(self.getMaximumSpike("disks", False, 1597662000000, 29), 0.4)

        # No visible activity after that
        self.assertLessEqual(self.getMaximumSpike("disks", False, 1597662000000, 30), 0.01)

    @testlib.nondestructive
    def testNoData(self):
        b = self.browser
        m = self.machine

        m.execute("systemctl stop pmlogger && mount -t tmpfs tmpfs /var/log/pcp/pmlogger")
        self.addCleanup(m.execute, "umount /var/log/pcp/pmlogger")

        self.login_and_go("/performance-graphs")
        b.wait_in_text(".pf-c-empty-state", "Metrics history could not be loaded")
        # Troubleshoot
        b.click(".pf-c-empty-state button.pf-m-link")
        b.enter_page("/system/services")
        b.wait_in_text("#service-details", "pmlogger.service")

    @testlib.nondestructive
    def testNoCockpitPcp(self):
        b = self.browser
        m = self.machine

        m.execute("mount -t tmpfs tmpfs /usr/share/cockpit/pcp")
        self.addCleanup(m.execute, "umount /usr/share/cockpit/pcp")

        self.login_and_go("/performance-graphs")
        b.wait_in_text(".pf-c-empty-state", "cockpit-pcp is missing")
        b.click(".pf-c-empty-state button.pf-m-primary")
        # this button does not yet do anything

    @testlib.nondestructive
    def testCurrentMetrics(self):
        b = self.browser
        m = self.machine

        self.login_and_go("/performance-graphs")

        def progressValue(progress_bar_sel):
            sel = progress_bar_sel + " .pf-c-progress__indicator"
            b.wait_present(sel)
            b.wait_attr_contains(sel, "style", "width:")
            style = b.attr(sel, "style")
            m = re.search("width: (\d+)%;", style)
            return int(m.group(1))

        # CPU

        nproc = m.execute("nproc").strip()
        b.wait_in_text("#current-cpu-usage", nproc + " CPU")
        # wait until system settles down
        b.wait(lambda: progressValue("#current-cpu-usage") < 20)
        m.spawn("for i in $(seq $(nproc)); do cat /dev/urandom > /dev/null & done", "cpu_hog.log")
        b.wait(lambda: progressValue("#current-cpu-usage") > 75)
        m.execute("pkill -e -f cat.*urandom")
        # should go back to idle usage
        b.wait(lambda: progressValue("#current-cpu-usage") < 20)

        # Memory

        # our test machines have ~ 1 GiB of memory, a reasonable chunk of it should be used
        b.wait_in_text("#current-memory-usage", " GiB")
        initial_usage = progressValue("#current-memory-usage")
        self.assertGreater(initial_usage, 10)
        self.assertLess(initial_usage, 80)
        # allocate an extra 300 MB; this may cause other stuff to get unmapped,
        # thus not exact addition, but usage should go up
        mem_hog = m.spawn("MEMBLOB=$(yes | dd bs=1M count=300 iflag=fullblock); touch /tmp/hogged; sleep infinity", "mem_hog.log")
        m.execute("while [ ! -e /tmp/hogged ]; do sleep 1; done")
        # bars update every 3s
        time.sleep(8)
        hog_usage = progressValue("#current-memory-usage")
        self.assertGreater(hog_usage, initial_usage + 8)

        m.execute("kill %d" % mem_hog)
        # should go back to initial_usage; often below, due to paged out stuff
        b.wait(lambda: progressValue("#current-memory-usage") <= initial_usage)
        self.assertGreater(progressValue("#current-memory-usage"), 10)

        # Disk usage

        # add 50 MB loopback disk
        m.execute("""set -e
                  F=$(mktemp /var/tmp/loop.XXXX)
                  dd if=/dev/zero of=$F bs=1M count=50
                  mkfs -t ext3 $F
                  mkdir -p /var/cockpittest
                  mount -o loop $F /var/cockpittest
                  rm $F
                  """)
        self.addCleanup(self.machine.execute, "umount /var/cockpittest")
        self.assertLess(progressValue(".pf-c-progress[data-disk-usage-target='/var/cockpittest']"), 5)
        free = b.text(".pf-c-progress[data-disk-usage-target='/var/cockpittest'] .pf-c-progress__status")
        # anything between 40 and 50 MB
        self.assertRegex(free, "^4\d\.\d MB free / 4\d\.\d MB total$")

        m.execute("dd if=/dev/zero of=/var/cockpittest/blob bs=1M count=40")
        b.wait(lambda: progressValue(".pf-c-progress[data-disk-usage-target='/var/cockpittest']") >= 90)


if __name__ == '__main__':
    testlib.test_main()
